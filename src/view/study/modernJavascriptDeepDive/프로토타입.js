// Ctrl + Alt + N : 실행
const log = console.log;

// 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다.

// 간혹 C++ 나 자바 같은 클래스 기반 객체지향 프로그래밍 언어의 특징인 클랙스와 상속, 캡슐화를 위한 키워드인 public, private, protected 등이 없어서 자바스크립트는 객체지향 언어가 아니라고 오해하는 경우도 있다.
// 하지만 자바스크립트는 클래스 기반 객체지향 프로그래밍 언어보다 효율적이며 더 강력한 객체지향 프로그래밍 능력을 지니고 있는 프로토타입 기반의 객체지향 프로그래밍 언어이다.

// 클래스

// ES6 에서 클래스가 도입되었다.
// 하지만 ES6 의 클래스가 기본 프로토타입 기반 객체지향 모델을 폐지하고 새로운 객체지향 모델을 제공하는 것은 아니다.
// 사실 클래스도 함수이며, 기존 프로토타입 기반 패턴의 문법적 설팅이라고 볼 수 있다.
// 클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하지 않는다.
// 클래스는 생성자 함수보다 엄격하며 클래스는 생성자 함수에서는 제공하지 않는 기능도 제공한다.

// 따라서 클래스를 프로토타입 기반 객체 생성 패턴의 단순한 문법적 설탕으로 보기보다는 새로운 객체 생성 매커니즘으로 보는것이 좀 더 합당하다고 할 수 있다.

// 자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 모든 것이 객체다.

// 원시 타입의 값을 제외한 나머지 값은 모두 객체다.

// 객체지향 프로그래밍은 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나
// 여러개의 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.

// 객체지향 프로그래밍은 실세계의 실체를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작한다.
// 

// 속성을 통해 여러개의 값을 하나의 단위로 구성한 복합적인 자료구조를 객체
// 객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.


// const circle = {
//     radius: 5,
//     getDiameter() {
//         return 2*this.radius;
//     },
//     getPerimeter() {
//         return 2*Math.PI*this.radius;
//     },
//     getArea() {
//         return Math.PI*this.radius**2;
//     }
// }

// log(circle.getDiameter())
// log(circle.getPerimeter())
// log(circle.getArea())

// 이처럼 객체지향 프로그래밍은 객체의 상태를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작을 하나의 논리적 단위로 묶어 생각한다.
// 따라서 객체는 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조 라고 할 수 있다.
// 객체의 상태 데이터를 프로퍼티, 동작을 메서드 라 부른다.


// 상속은 객체지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수있는 것을 말한다.
// 자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다.

// function Circle(radius) {
//     this.radius = radius;
//     this.getArea = function() {
//         return Math.PI * this.radius ** 2;
//     }
// }

// const circle1 = new Circle(1);
// const circle2 = new Circle(2);

// log(circle1.getArea());
// log(circle2.getArea());

// getArea 메서드는 모든 인스턴스가 동일한 내용의 메서드를 사용하므로 단 하나만 생성항여 모든 인스턴스가 공유해서 사용하는 것이 바람직하다.
// 그런데 Circle 생성자 함수는 인스턴스를 생성할 때마다 getArea 메서드를 중복 생성하고 모든 인스턴스가 중복 소유한다.
// 이처럼 동일한 생성자 함수에 의해 생성된 모든 인스턴스가 동일한 메서드를 중복 소유하는 것은 메모리를 불필요하게 낭비한다.
// 또한 인스턴스를 생성할 때마다 메서드를 생성하므로 퍼포먼스에도 악영향을 준다.
// 만약 10개의 인스턴스를 생성하면 내용이 동일한 메서드도 10개 생성된다.

// 상속을 통해 불필요한 중복을 제거하자, 자바스크립트는 프로토타입을 기반으로 상속을 구현한다.

// function Circle(radius) {
//     this.radius = radius;
// }

// Circle.prototype.getArea = function() {
//     return Math.PI * this.radius ** 2;
// }

// const circle1 = new Circle(1);
// const circle2 = new Circle(2);

// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체 역할을 하는
// 프로토타입 Circle.prototype 으로부터 getArea 메서드를 상속받는다.
// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메서드를 공유한다.

// log(circle1.getArea === circle2.getArea);
// log(circle1.getArea());
// log(circle2.getArea());

// Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 부모 객체 역할을 하는 Circle.prototype 의 모든 프로퍼티와 메서드를 상속받는다.
// getArea 메서드는 단 하나만 생성되어 프로토타입 Circle.prototype 의 메서드로 할당되어 있다.
// 즉 자신의 상태를 나타내는 radius 프로퍼티만 개별적으로 소유하고 내용이 동일한 메서드는 상속을 통해 공유하여 사용하는 것이다.

// 상속은 코드의 재사용이란 관점에서 매우 유용하다.
// 생성자 함수가 생성할 모든 인스턴스가 공통적으로 프로퍼티나 메서드를 프로토타입에 미리 구현해 두면 생성자 함수가 생성할 모든 인스턴스는 별도의 구현없이 부모 객체인 프로토타입의 자산을 공유하여 사용할 수 있다.


// 프로토타입 객체

// 프로토타입 객체란 객체지향 프로그밍의 근간을 이루는 객체간 상속을 구현하기 위해 사용된다.
// 프로토타입은 어떤 객체의 부모 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티,메서드를 제공한다.
// 프로토타입을 상속받은 자식 객체는 부모 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.

// 모든 객체는 [[Prototype]] 이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값은 프로토타입의 참조다.
// 객체가 생성될때 객체 생성 방식에 따라 프로토타입이 결정되고 [[Prototype]] 에 저장된다.

// 예를 들어 객체 리터럴에 의해 생성된 객체의 프로토타입은 Object.prototype 이고 생성자 함수에 의해 생성된 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체다.

// 모든 객체는 하나의 프로토타입을 갖는다.
// 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다.


// 모든 객체는 __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다.

// const person = {
//     name: 'Lee'
// };

// log(person.__proto__.constructor);


// 프로토타입의 참조를 취득하고 싶은 경우에는 Object.getPrototypeOf 메서드를 사용하고
// 프로토타입을 교체하고 싶은 겨우에는 Object.setPrototypeOf 메서드를 사용할 것을 권장한다.

// const obj = {};
// const parent = {x:1};

// log(Object.getPrototypeOf(obj));
// Object.setPrototypeOf(obj, parent);
// log(obj.x);

// 함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.

// log((function() {}).hasOwnProperty('prototype'));
// log({}.hasOwnProperty('prototype'));

// 함수 객체는 prototype 프로퍼티를 소유한다.
// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.

// 생성자 함수로서 호출할 수 없는 즉 non-constructor 인 화살표 함수와 ES6 메서드 축약 포현으로 정의한 메서드는 prototype 프로퍼티를 소유하지 않으며 프로토타입도 생성하지 않는다.

// const Person = name => {
//     this.name = name;
// }

// log(Person.hasOwnProperty('prototype'));

// const obj = {
//     foo() {}
// };

// log(obj.foo.hasOwnProperty('prototype'));

// 생성자 함수로 호출하기 위해 정의하지 않은 일반함수(함수선언문,함수표현식) 도 prototype 프로퍼티를 소유하지만
// 객체를 생성하지 않는 일반 함수의 prototype 프로퍼티는 아무런 의미가 없다.

// 모든 객체가 가지고 있는(엄밀히 말하면 Object.prototype 으로부터 상속받은) __proto__ 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다.


// log(window)

