<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title><%=pageName%></title>
    <link type="text/css" rel="stylesheet" href="/style/editor.css">
    <script type="text/javascript" src="/script/studyScript.js"></script>
</head>
<body>
    <div style="width: 100%; display: flex; justify-content: center;">
        <div style="padding: 10px 20px; border: 1px solid black; width: 1500PX;">
            <div class="button-area">
                <div style="display: flex; align-items: center;">
                    <h2 class="fileName" style="font-weight: 600;"><%=pageName%></h2>
                </div>
                <div>
                    <button id="pdfBtn" class="editor-button">pdf</button>
                    <button id="updateBtn" class="editor-button">수정</button>
                </div>
            </div>
            <div class="contents-section">
                <div>
                    <textarea id="editor" style="width:1455PX;height:700px;"></textarea>
                </div>
            </div>
        </div>
    </div>
    <input type="hidden" id="category" value="<%=category%>"/>
    <input type="hidden" id="page" value="<%=page%>"/>
</body>
</html>

<script>
    // 프로미스

    // 자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다.
    // 하지만 전통적인 콜백 패턴은 콜백 헬로 인해 가독성이 나쁘고 비동기 처리 중 발생한 에러의 처리가 곤란하며 여러 개의 비동기 처리를 한번에 처리하는 데도 한계가 있다.

    // ES6 에서는 비동기 처리를 위한 또 다른 패턴으로 프로미스를 도입했다.
    // 프로미스는 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있다는 장점이 있다.

    // 비동기 처리를 위한 콜백 패던의 단점

    // 콜백 헬

    const get = url => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.send();

        xhr.onload = () => {
            if(xhr.status === 200) {
                console.log(JSON.parse(xhr.response));
            } else {
                console.log(`${xhr.status} ${xhr.statusText}`);
            }
        }
    }

    // get('/test/promise1');
    // console.log(1);

    // get 함수는 비동기 함수다.
    // 비동기 함수란 함수 내부에 비동기로 동작하는 코드를 포함하는 함수를 말한다.

    // 비동기 함수를  호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않았다 해도 기다리지 않고 즉시 종료된다.
    // 즉 비동기 함수 내부의 비동기로 동작하는 코드는 비동기 함수가 종료된 이후에 완료된다.
    // 따라서 비동기 함수 내부의 비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로 동작하지 않는다.

    // let g = 0;
    // setTimeout(() => {g = 100});
    // console.log(g);

    // GET 요청을 전송하고 서버의 응답을 전달받는 get 함수도 비동기 함수다.
    // get 함수가 비동기 함수인 이유는 get 함수 내부의 onload 이벤트 핸들러가 비동기로 동작하기 때문이다.

    // get 함수를 호출하면 GET 요청을 전송하고 onload 이벤트 핸들러를 등록한 다음 undefined 를 반환하고 즉시 종료된다.
    // 즉, 비동기 함수인 get 함수 내부의 onload 이벤트 핸들러는 get 함수가 종료된 이후에 실행된다.
    // 따라서 get 함수의 onload 이벤트 핸들러에서 서버의 응답 결과를 반환하거나 상위 스코프으 ㅣ 변수에 할당하면 기대한 대로 동작하지 않는다.

    const resonse = get('/test/promise1');
    console.log('resonse', resonse);

    // 

</script>