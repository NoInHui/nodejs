// Ctrl + Alt + N : 실행

const log = console.log;

// 제너레이터와 async/await

// 제너레이터는 코드 블록의 실행을 일시 중지 했다가 필요한 시점에 재개할 수 있는 특수한 함수다.

// 제너레이터와 일반 함수의 차이는 다음과 같다.

// 1. 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있따.
// 일반 함수를 호출하면 제어권이 함수에게 넘어가고 함수 코드를 일괄 실행한다.
// 즉 함수 호출자는 함수를 호출한 이후 함수 실행을 제어할 수 없다.
// 제너레이터 함수는 함수 실행을 함수 호출자가 제어할 수 있다.
// 다시 말해 함수 호출자가 함수 실행을 이시 중지시키거나 재개시킬 수 있다.
// 이는 함수의 제어권을 함수가 독점하는 것이 아니라 함수 호출자에게 양도(yield)할 수 있다는 것을 의미한다.

// 2. 제너레이터 함수는 함수 호출자와 함수의 상태를 주고받을 수 있다.
// 일반 함수를 호출하면 매개변수를 통해 함수 외부에서 값을 주입받고 함수 코드를 일괄 실행하여 결과값을 함수 외부로 반환한다.
// 즉, 함수가 실행되고 있는 동안에는 함수 외부에서 함수 내부로 값을 전달하여 함수의 상태를 변경할 수 없다.
// 제너레이터 함수는 함수 호출자와 양방향으로 함수의 상태를 주고받을 수 있다.
// 제너레이터 함수는 함수 호출자에게 상태를 전달할 수 있고 함수 호출자로부터 상태를 전달받을 수 도있다.

// 3. 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.
// 일반 함수를 호출하면 함수 코드를 일괄 실행하고 값을 반환한다.
// 제너레이터 함수를 호출하면 함수 코드를 실행하는 것이 아니라 이터러블이면서 동시에 이터레이터인 제너레이터 객체를 반환한다.

// 제너레이터 함수를 호출하면 일반 함수처럼 코드 블록을 실행하는 것이 아니라 제너레이터 객체를 생성해 반환한다.
// 제너레이터 함수가 반환한 제너레이터 객체는 이터러블 이면서 동시에 이터레이터 다.

// 제너레이터 객체는 Symbol.iterator 메서드를 상속받는 이터러블이면서 value,done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환하는 next 메서드를 소유하는 이터레이터다.
// 제너레이터 객체는 next 메서드를 가지는 이터레이터이므로 Symbol.iterator 메서드를 호출해서 별도로 이터레이터를 생성할 필요가 없다.

// function* getFunc() {
//     yield 1;
//     yield 2;
//     yield 3;
//     yield 4;
// }

// const gen = getFunc();
// log(Symbol.iterator in gen);
// log(gen.next());
// log(gen.next());
// log(gen.next());
// log(gen.next());
// log(gen.next());

// 제너레이터 객체는 next 메서드를 갖는 이터레이터이지만, 이터레이터에는 없는 return,throw 메서드를 갖는다.

// next 메서드를 호출하면 제너레이터 함수의 yield 표현식까지 코드 블록을 실행하고 yield 된 값을 value 프로퍼티 값으로 false 를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환한다.
// return 메서드를 호출하면 인수로 전달받은 값을 value 프로퍼티 값으로, true 를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환한다.

// function* getFunc() {
//     yield 1;
//     yield 2;
//     yield 3;
//     yield 4;
// }

// const gen = getFunc();

// log(gen.next());
// log(gen.next());
// log(gen.return('end'));
// log(gen.next());

// throw 메서드를 호출하면 인수로 전달받은 에러를 발생시키고 undefined를 value 프로퍼티 값으로 true 를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환한다.

// function* getFunc() {
//     try {
//         log(1111111111111)
//         yield 1;
//         log(222222222222)
//         yield 2;
//         log(333333333)
//         yield 3;
//         log(4444444444444)
//         yield 4;
//         log(55555555555)
//     } catch(e) {
//         log(e);
//     }
// }

// const gen = getFunc();

// log(gen.next());
// log(gen.next());
// // log(gen.throw('Errror'));
// log(gen.next());
// log(gen.next());
// log(gen.next());
// log(gen.next());

// 제너레이터의 일시 중지와 재개

// 제너레이터는 yield 키워드와 next 메서드를 통해 실행을 일시 중지했다가 필요한 시점에 다시 재개할 수 있다.
// 일반 함수는 호출 이후 제어권을 함수가 독점하지만 제너레이터는 함수 호출자에게 제어권을 양도하여 필요한 시점에 함수 실행을 재개할 수 있다.
// 제너레이터 함수를 호출하면 제너레이터 함수의 코드 블록이 실행되는 것이 아니라 제너레이터 객체를 반환한다고 했다.
// 이터러블이면서 동시에 이터레이터인 제너레이터 객체는 next 메서드를 갖는다.
// 제너레이터 객체의 next 메서드를 호출하면 제너레이터 함수의 코드 블록을 실행한다.
// 단 일반 함수처럼 한 번에 코드 블록의 모든 코드를 일괄 실행하는 것이 아니라 yield 표현식까지만 실행한다.

// yield 키워드는 제너레이터 함수의 실행을 일시 중지시키거나 yield 키워드 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 반환한다.

// 제너레이터 객체의 next 메서드를 호출하면 yield 표현식까지 실행되고 일시 중지된다.
// 이때 함수 제어권이 호출자로 양도된다.
// 이후 필요한 시점에 호출자가 다시 next 메서드를 호출하면 일시 중지된 코드부터 실행을 재개하기 시작하여 다음 yield 표현씩까지 실행되고 또 다시 일시 중지된다.

// 이때 제너레이터 객체의 next 메서드는 value,done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다.
// next 메서드가 반환한 이터레이터 리절트 객체의 value 프로퍼티에는 yield 표현식에서 yield 된 값 이 할당되고 done 프로퍼티에는 제너레이터 함수가 끝까지 실행되었는지를 나타내는 boolean 값이 할당된다.

// 이터레이터의 next 메서드와 달리 제너레이트 객체의 next 메서드에는 인수를 전달할 수 있다.
// 제너레이터 객체의 next 메서드에 전달한 인수는 제너레이터 함수의 yield 표현식을 할당받는 변수에 할당된다.

// function* getFunc() {
//     try {
//         const x = yield 1;


//     } catch(e) {
//         log(e);
//     }
// }