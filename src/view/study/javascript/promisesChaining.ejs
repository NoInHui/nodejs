<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title><%=pageName%></title>
    <link type="text/css" rel="stylesheet" href="/style/editor.css">
    <script type="text/javascript" src="/script/studyScript.js"></script>
</head>
<body>
    <div style="width: 100%; display: flex; justify-content: center;">
        <div style="padding: 10px 20px; border: 1px solid black; width: 1500PX;">
            <div class="button-area">
                <div style="display: flex; align-items: center;">
                    <h2 class="fileName" style="font-weight: 600;"><%=pageName%></h2>
                </div>
                <div>
                    <button id="pdfBtn" class="editor-button">pdf</button>
                    <button id="updateBtn" class="editor-button">수정</button>
                </div>
            </div>
            <div class="contents-section">
                <div>
                    <textarea id="editor" style="width:1455PX;height:700px;"></textarea>
                </div>
            </div>
        </div>
    </div>
    <input type="hidden" id="category" value="<%=category%>"/>
    <input type="hidden" id="page" value="<%=page%>"/>
</body>
</html>

<script>
// Promise Chaining

// 스크립트를 불러오는 것과 같이 순차적으로 처리해야 하는 비동기 작업이 여러 개 있다고 가정해 봅시다.
// 어떻게 해야 이런 상황을 코드로 풀어낼 수 있을까요?

// 프라미스를 사용하면 여러 가지 해결책을 만들 수 있습니다.
// 이번 챕터에선 프라미스 체이닝을 이용한 비동기 처리에 대해 다루도록 하겠습니다.

// 프라미스 체이닝은 아래와 같이 생겼습니다.

new Promise(function(resolve, reject) {
    setTimeout(() => resolve(1), 1000);
}).then(
    // function(result) {
    //     console.log(result);
    //     return result * 2;
    // }
    (result) => result * 2
).then(
    (result) => result * 2
).then(
    (result) => result * 2
).then(
    (result) => console.log('result', result)
);

// 프라미스 체이닝은 result 가 .then 핸들러의 체인을 통해 전달된다는 점에서 착안한 아이디어입니다.

// 위 예시는 아래와 같은 순서로 실행됩니다.

// 1. 1초 후 최초 프라미스가 이행됩니다.
// 2. 이후 첫번째 .then 핸들러가 호출됩니다.
// 3. 2에서 반환한 값은 다음 .then 핸들러에 전달됩니다.
// 4. 이런 과정이 계속 이어집니다.

// result 가 핸들러 체인을 전달됩니다.

// new Promise -> resolve(1) -> .then -> return 2 -> .then -> return 4 -> .then -> return 8

// 프라미스 체이닝이 가능한 이유는 promise.then 을 호출하면 프라미스가 반환되기 때문입니다.
// 반환된 프라미스엔 당연히 .then 을 호출할 수 있습니다.

// 한편 핸들러가 값을 반환할 때엔 이 값이 프라미스의 result 가 됩니다.
// 따라서 다음 .then 은 이 값을 이용해 호출됩니다.

// 초보자는 프라미스 하나에 .then 을 여러 개 추가한 후, 이를 체이닝이라고 착각하는 경우가 있습니다.
// 하지만 이는 체이닝이 아닙니다.




</script>