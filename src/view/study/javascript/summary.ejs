<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title><%=pageName%></title>
    <link type="text/css" rel="stylesheet" href="/style/editor.css">
    <script type="text/javascript" src="/script/studyScript.js"></script>
</head>
<body>
    <div style="width: 100%; display: flex; justify-content: center;">
        <div style="padding: 10px 20px; border: 1px solid black; width: 1500PX;">
            <div class="button-area">
                <div style="display: flex; align-items: center;">
                    <h2 class="fileName" style="font-weight: 600;"><%=pageName%></h2>
                </div>
                <div>
                    <button id="pdfBtn" class="editor-button">pdf</button>
                    <button id="updateBtn" class="editor-button">수정</button>
                </div>
            </div>
            <div class="contents-section">
                <div>
                    <textarea id="editor" style="width:1455PX;height:700px;"></textarea>
                </div>
            </div>
        </div>
    </div>
    <input type="hidden" id="category" value="<%=category%>"/>
    <input type="hidden" id="page" value="<%=page%>"/>
</body>
</html>

<script>

// 프로퍼티와 플래그
// 1. writable : true 이면 값을 수정할 수 있습니다. 그렇지 않다면 읽기만 가능합니다.
// 2. enumerable : true 이면 반복문을 사용해 나열할 수 있습니다. 그렇지 않다면 반복문을 사용해 나열할 수 없습니다.
// 3. configurable : true 이면 프로퍼티 삭제나 플래그 수정이 가능합니다. 그렇지 않다면 프로퍼티 삭제와 플래그 수정이 불가능합니다.

let obj1 = {
    name: 'inhui',
    old: 32,
    array: [1,2,3,4],
};

// 프로퍼티 플래그 관련 메서드
console.log(Object.getOwnPropertyDescriptor(obj1, 'array'));
console.log(Object.getOwnPropertyDescriptors(obj1));

Object.defineProperty(obj1, 'surname', {
    value: 'noh',
    enumerable: false,
    configurable: false,
    writable: false,
});

let obj2 = Object.defineProperties({}, {
    name: {value:'tom', writable:true, enumerable:true, configurable: true},
    surname: {value:'kim'}
});

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------

// 접근자 프로퍼티 getter 와 setter

// 객체의 프로퍼티는 두 종류로 나뉩니다.
// 1. 데이터 프로퍼티(data property) : 보통 사용하는 프로퍼티
// 2. 접근자 프로퍼티(access property) : 접근자 프로퍼티의 본질은 함수, 이 함수는 값을 get, set 하는 역할을 담당, 외부 코드에서는 함수가 아닌 일반적인 프로퍼티처럼 보입니다.

// 접근자 프로퍼티는 객체 리터럴 안에서 getter,setter 메서드는 get,set 으로 나타낼 수 있습니다.
let obj3 = {
    surname: 'noh',
    name: 'inhui',
    get fullName() {
        return `${this.surname} ${this.name}`;
    },
    set fullName(value) {
        if(Object.getPrototypeOf(value) === Array.prototype && value.length == 2) {
            [this.surname, this.name] = value;
        } else {
            console.log('not set fullName');
            return;
        }   
    }
};

obj3.fullName = ['kim','eunji'];

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------

// 프로토타입 상속

// [[Prototype]] : 자바스크립트 객체는 명세서에서 명명한 [[Prototype]] 이라는 숨김 프로퍼티를 갖습니다.
// [[Prototype]] 값은 null 이거나 다른 객체에 대한 참조가 되는데, 다른 객체를 참조하는 경우 참조 대상을 '프로토타입' 이라 부릅니다.

// __proto__ : [[Prototype]] 용 getter, setter 입니다.
// __proto__ 는 하위 호환성 때문에 여전히 사용하지만 비교적 근래에 작성된 스크립트에는 함수 Object.getPrototypeOf , Object.setPrototypeOf 를 사용해 get,set 합니다.

let obj4 = {
    eats: true,
    walk() {
        return `call keys : ${Object.keys(this)} , walk()`;
    }
};

let obj5 = {
    jumps: true,
    __proto__ : obj4
};

let obj6 = {
    earLength: 10
};

obj6.__proto__ = obj5;

console.log(obj6.walk());

// 프로토타입 체이닝엔 두 가지 제약사항이 있습니다.
// 1. 순환 참조(circular reference) 는 허용되지 않습니다.
// 2. __proto__ 의 값은 null 또는 객체만 가능합니다. 다른 자료형은 무시됩니다.

// 프로토타입은 읽기 전용입니다.
// 프로토타입에 프로퍼티를 추가,수정,삭제 연산은 객체에 직접 해야 합니다.

let obj7 = {
    surname: 'noh',
    name: 'inhui',
    get fullName() {
        return `${this.surname} ${this.name}`;
    },
    set fullName(value) {
        if(Object.getPrototypeOf(value) === Array.prototype && value.length == 2) {
            [this.surname, this.name] = value;
        } else {
            console.log('not set fullName');
            return;
        }   
    }
};

let obj8 = {
    __proto__: obj7,
    isAdmin: true,
};

obj8.fullName = ['kim','eunji'];

console.log(obj7.fullName, obj8.fullName);
// obj7 의 surname, name 프로퍼티는 변경되지 않았습니다.
// 메서드를 객체에서 호출했든 프로토타입에서 호출했든 상관없이 this 는 언제나 . 앞에 있는 객체입니다.

let obj9 = {
    __proto__: obj7,
    isAdmin: true,
}

// Object.keys 는 객체 자신의 키만 반환합니다.
console.log(Object.keys(obj9));

// for..in 은 상속 프로퍼티도 순회대상에 포함시킵니다.
for(let key in obj9) console.log(key);

// obj.hasOwnProperty(key) 를 이용하면 상속 프로퍼티를 순회 대상에서 제외할 수 있습니다.
for(let key in obj9) {
    if(obj9.hasOwnProperty(key)) {
        console.log('exist key : ' + key);
    } else {
        console.log('prototype key : ' + key);
    }
};

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------

// 함수의 prototype 프로퍼티

// 함수의 디폴트 프로퍼티 prototype 과 constructor 프로퍼티
// 개발자가 특별히 할당하지 않더라도 모든 함수는 기본적으로 prototype 프로퍼티를 갖습니다.
// default 프로퍼티 prototype 은 constructor 프로퍼티 하나만 있는 객체를 가리키는데, 여기서 constructor 프로퍼티는 함수 자신을 가리킵니다.

function func1() {};
console.log(func1.prototype.constructor === func1);

// 특별한 조작을 가하지 않았다면 new function 을 실행해 만든 객체 모두에서 constructor 프로퍼티를 사용할 수 있는데, 이때 [[Prototype]] 을 거칩니다.

let func2 = new func1(); // {constructor: func1} 을 상속받음
console.log(func2.constructor == func1); // [[Prototype]] 을 거쳐 접근함

// constructor 프로퍼티는 기존에 있던 객체의 constructor 를 사용해 새로운 객체를 만들때 사용할 수 있습니다.
let func3 = new func2.constructor;

// 자바스크립트는 알맞은 'constructor' 값을 보장하지 않습니다.
// 함수엔 기본적으로 prototype 이 설정된다라는 사실 그게 전부입니다.
// constructor 와 관련해서 벌어지는 모든 일은 전적으로 개발자에게 달려있습니다.

function func4() {};
func4.prototype = {
    jumps: true
};

let func5 = new func4();
console.log(func5.constructor === func4);

// constructor 의 기본 성질을 제대로 활용하려면 prototype 전체를 덮어쓰지 말고 원하는 프로퍼티를 추가,제거해야 합니다.

function func6() {};
func6.prototype.jumps = true;

// constructor 프로퍼티를 수동으로 다시ㅏ 만들어주면 constructor 를 다시 사용할 수 있습니다.
func4.prototype.constructor = func4;

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------

// 내장 객체의 프로토타입

// 모든 내장 생성자 함수에서 prototype 프로퍼티를 사용합니다.
// new Object() 를 호출하거나 리터럴 문법 {...} 을 사용해 객체를 만들 때, 새롭게 생성된 객체의 [[Prototype]] 은 규칙에 따라 Object.prototype 을 참조합니다.

let obj10 = {};
console.log(obj10.__proto__ === Object.prototype);
console.log(obj10.toString === Object.prototype.toString);

// 다양한 내장 객체의 프로토타입
// Array, Date, Function 을 비롯한 내장 객체들 역시 프로토타입에 메서드를 저장해 놓습니다.

// 원시값
// 문자열,숫자,불린값은 객체가 아닙니다.
// 이런 원시 타입 값의 프로퍼티에 접근하려고 하면 내장 생성자 String, Number, Boolean 을 사용하는 임시 래퍼(wrapper)객체가 생성됩니다.
// 임시 래퍼 객체는 이런 메서드를 제공하고 난 후 사라집니다.
// 래퍼 객체는 보이지 않는 곳에서 만들어지는데 엔진에 의해 최적화가 이뤄집니다.

// null, undefined 에 대응하는 래퍼 객체는 없습니다.
// 따라서 null 과 undefined 에선 메서드와 프로퍼티를 이용할 수 없습니다.
// 프로토타입도 물론 사용할 수 없습니다.

// 네이티브 프로토타입은 수정할 수 있습니다.
String.prototype.test1 = function() {
    return `String.prototype.test1 by ${this}`;
};
console.log('inhui'.test1());

// 네이티브 프로토타입을 수정하는 것은 기존 코드와 충돌이 날 가능성이 크기 때문에 수정하지 않는게 좋습니다.
// 다만 폴리필을 만들때는 허용합니다.

// 프로토타입에서 메서드 빌려오기
let obj11 = {
    0: 'hello',
    1: 'world',
    length: 2,
};

obj11.join = Array.prototype.join;
console.log(obj11.join(','));

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------

// 프로토타입 메서드와 __proto__ 가 없는 객체

// 프로토타입을 설정하기 위한 모던한 메서드

let obj12 = {
    eats: true
};

// Object.create(proto, [descriptors])
// [[Prototype]] 이 proto 를 참조하는 빈 객체를 만듭니다. 이때 프로퍼티 설명자를 추가로 넘길 수 있습니다.
let obj13 = Object.create(obj12, {
    name: {
        value: 'inhui',
        writable: false,
        enumerable: false,
        configurable: false,
    }
});

// obj 의 [[Prototype]] 을 반환합니다.
console.log(Object.getPrototypeOf(obj13));

// obj의 [[Prototype]] 이 proto 가 되도록 설정합니다.
Object.setPrototypeOf(obj13, {jumps: false});

// Object.create 를 사용하면 효과적으로 객체를 복사할 수 있습니다.
let obj14 = Object.create(Object.getPrototypeOf(obj13), Object.getOwnPropertyDescriptors(obj13));

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------






// ----------------------------------------------------------------------------------------------------------------------------------------------------------------

// 객체 복사 방법
let copy1 = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj1));
let copy2 = Object.create(Object.getPrototypeOf(obj1), Object.getOwnPropertyDescriptors(obj1));




</script>