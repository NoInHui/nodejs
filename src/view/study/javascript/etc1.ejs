<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title><%=pageName%></title>
    <link type="text/css" rel="stylesheet" href="/style/editor.css">
    <script type="text/javascript" src="/script/studyScript.js"></script>
</head>
<body>
    <div style="width: 100%; display: flex; justify-content: center;">
        <div style="padding: 10px 20px; border: 1px solid black; width: 1500PX;">
            <div class="button-area">
                <div style="display: flex; align-items: center;">
                    <h2 class="fileName" style="font-weight: 600;"><%=pageName%></h2>
                </div>
                <div>
                    <button id="pdfBtn" class="editor-button">pdf</button>
                    <button id="updateBtn" class="editor-button">수정</button>
                </div>
            </div>
            <div class="contents-section">
                <div>
                    <textarea id="editor" style="width:1455PX;height:700px;"></textarea>
                </div>
            </div>
        </div>
    </div>
    <input type="hidden" id="category" value="<%=category%>"/>
    <input type="hidden" id="page" value="<%=page%>"/>
</body>
</html>

<script>

// async 와 await

// async 함수
// function 앞에 async 를 붙이면 해당 함수는 항상 프라미스를 반환합니다.
// 프라미스가 아닌 값을 반환하더라도 이행 상태의 프라미스(resolved promise)로 값을 감싸 이행된 프라미스가 반환되도록 합니다.

async function func1() {
    return 'func1';
}

function func2() {
    return 'func2';
}

console.log(func1()); // fulfilled promise
console.log(func2());

// 명시적으로 프라미스를 반환하는 것도 가능합니다. 결과는 동일합니다.

async function func3() {
    return new Promise((resolve, reject) => resolve('func3'));
}

console.log(func3());

// async 가 붙은 함수는 반드시 프라미스를 반환하고, 프라미스가 아닌 것은 프라미스로 감싸 반환합니다.
func3().then(result => console.log(result));

// await
// await 는 async 함수 안에서만 동작합니다.
// 자바스크립트는 await 키워드를 만나면 프라미스가 처리될 때까지 기다립니다. 결과는 그 이후 반환됩니다.

async function func4() {
    let promise = new Promise((resolve, reject) => {
        setTimeout(() => resolve('func4'), 3000);
    });

    let result = await promise; // 프라미스가 이행될 때까지 기다림
    console.log(result);
    console.log('func4 after??')
}

func4();

// await 는 말 그대로 프라미스가 처리될 때까지 함수 실행을 기다리게 만듭니다.
// 프라미스가 처리되면 그 결과와 함께 실행이 재개되죠.
// 프라미스가 처리되길 기다리는 동안엔 엔진이 다른 일(다른 스크립트 실행, 이벤트 처리 등)을 할 수 있기 때문에, CPU 리소스가 낭비되지 않습니다.

// await 는 promise.then 보다 좀 더 세력되게 프라미스의 result 값을 얻을 수 있도록 해주는 문법입니다.

async function func5() {
    let response = await fetch('/save/jsonData.json');
    let data = await response.json();
    return data;
}

func5();

// await 는 최상위 레벨 코드에서 작동하지 않습니다.
// 하지만 익명 async 함수로 코드를 감싸면 최상위 레벨 코드에도 await 를 사용할 수 있습니다.

(async () => {
    let response = await fetch('/save/jsonData.json');
    let data = await response.json();
    console.log(data);
})();

// 에러 핸들링

// 프라미스가 정상적으로 이행되면 await promise 는 프라미스 객체의 result 에 저장된 값을 반환합니다.
// 반면에 프라미스가 거부되면 마치 throw 문을 작성한 것처럼 에러가 던져집니다.
// await 가 던진 에러는 throw 가 던진 에러를 잡을 때처럼 try..catch 를 사용해 잡을 수 있습니다.

async function func6() {
    try {
        let response = await fetch('http://none');
    } catch(e) {
        console.log(e);
    }
}

func6();

// try..catch 가 없으면 async 함수를 호출해 만든 프라미스가 거부 상태가 됩니다.
// .catch 를 추가하면 거부된 프라미스를 처리할 수 있습니다.

async function func7() {
    try {
        let response = await fetch('http://none');
    } catch(e) {
        console.log(e);
    }
}

func7().catch(e => console.log(e));

// .catch 를 추가하는 걸 잊으면 처리되지 않은 프라미스 에러가 발생합니다.
// 이런 에러는 전역 이벤트 핸들러 unhandledrejection 을 사용해 잡을 수 있습니다.

// async/await 와 promise.then/catch
// async/await 을 사용하면 await 가 대기를 처리해주기 때문에 .then 이 거의 필요하지 않습니다.
// 여기에 더하여 .catch 대신 일반 try..catch 를 사용할 수 있다는 장점도 생깁니다.
// 그런데 문법 제약 때문에 async 함수 바깥의 최상위 레벨 코드에선 await 를 사용할 수 없습니다.
// 그렇기 때문에 관행처럼 .then/catch 를 추가해 최종 결과나 처리되지 못한 에러를 다룹니다.

// async / await 는 Promise.all 과도 함께 쓸 수 있습니다.

(async function() {
    let results = await Promise.all([
        (await fetch('/save/jsonData.json')).json(),
        new Promise((resolve,reject) => resolve('promise1')),
    ]);
    console.log('Promise.all', results);
})();




</script>