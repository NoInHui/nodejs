<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title><%=pageName%></title>
    <link type="text/css" rel="stylesheet" href="/style/editor.css">
    <script type="text/javascript" src="/script/studyScript.js"></script>
</head>
<body>
    <div style="width: 100%; display: flex; justify-content: center;">
        <div style="padding: 10px 20px; border: 1px solid black; width: 1500PX;">
            <div class="button-area">
                <div style="display: flex; align-items: center;">
                    <h2 class="fileName" style="font-weight: 600;"><%=pageName%></h2>
                </div>
                <div>
                    <button id="pdfBtn" class="editor-button">pdf</button>
                    <button id="updateBtn" class="editor-button">수정</button>
                </div>
            </div>
            <div class="contents-section">
                <div>
                    <textarea id="editor" style="width:1455PX;height:700px;"></textarea>
                </div>
            </div>
        </div>
    </div>
    <input type="hidden" id="category" value="<%=category%>"/>
    <input type="hidden" id="page" value="<%=page%>"/>
</body>
</html>

<script>

// 나머지 매개변수와 스프레드 문법

// 나머지 매개변수 ...
// 함수 정의 방법과 상관없이 함수에 넘겨주는 인수의 개수엔 제약이 없습니다.
function func1(a,b) {
    console.log(a+b);
}

func1(1,2,3,4);

// 아래 예시에선 모든 인수가 배열 args 에 모입니다.
// ... 는 남아있는 매개변수들을 한데 모아 배열에 집어넣어라 는 것을 의미합니다.
function func2(...args) {
    let sum = args.reduce((acc,cur,i) => {
        acc += cur;
        return acc;
    },0);
    console.log(sum);
}

func2(1,2,3,4);

// 앞부분의 매개변수는 변수로, 남아있는 매개변수들은 배열로 모을 수 있습니다.
function func3(a,b,...args) {
    let sum = a+b;
    sum = args.reduce((acc,cur,i) => {
        acc += cur;
        return acc;
    },sum);
    console.log(sum);
}

func3(1,2,3,4);

// 나머지 매개변수는 항상 마지막에 있어야 합니다.
// 나머지 매개변수는 남아있는 인수를 모으는 역할을 하므로 아래 예시에선 에러가 발생합니다.
// function func(...args, a,b) { }

// arguments 객체
// 유사 배열 객체(array-like object)인 arguments 를 사용하면 인덱스를 사용해 인수에 접근할 수 있습니다.

function func4() {
    console.log(arguments, arguments.length, arguments[2]);
}

func4(1,2,3,4);

// 나머지 매개변수는 비교적 최신에 나온 문법입니다.
// 나머지 매개변수가 나오기 이전엔 함수의 인수 전체를 얻어내는 방법이 arguments 를 사용하는 것밖에 없었습니다.
// 물론 지금도 arguments 를 사용할 수 있습니다. 오래된 코드를 보다 보면 arguments 를 만나게 되죠.

// 화살표 함수는 arguments 객체를 지원하지 않습니다.
// 화살표 함수에서 arguments 객체에 접근하면, 외부에 있는 '일반'함수의 arguments 객체를 가져옵니다.

function func5() {
    let func = () => {
        console.log(arguments);
    }
    func();
}

func5(1,2,3,4);

// 스프레드 문법
// 매개변수와는 반대로 배열을 인수 목록으로 반환합니다.
// 내장함수 Math.max 는 인수로 받은 숫자 중 가장 큰 숫자를 반환합니다.

function func6(array) {
    console.log(Math.max(array)); // NaN
    console.log(Math.max(...array)); // 최대값 뽑아냄
}

func6([1,2,3,4]);

// Math.max(a,b,c,d) 처럼 배열 요소를 수동으로 나열하는 방법도 있긴 한데, 배열 길이를 알 수 없을 때는 이마저도 불가능합니다.
// 스크립트가 돌아갈 때 실제 넘어오는 배열의 길이는 아주 길 수도 있고, 아예 빈 배열일 수도 있기 때문입니다.

// 스프레드 문법(spread syntax, 전개문법)은 이럴 때 사용하기 위해 만들어졌습니다.
// ... 를 사용하기 때문에 나머지 매개변수와 비슷해 보이지만, 스프레드 문법은 나머지 매개변수와 반대되는 역할을 합니다.
// 함수를 호출할 때 ...arr 를 사용하면, 이터러블 객체 arr 이 인수 목록으로 확장 됩니다.

// 아래와 같이 이터러블 객체 여러 개를 전달하는 것도 가능합니다.

let arr1 = [1,2,3,4];
let arr2 = [5,6,7,8];
console.log(Math.max(...arr1, 10, ...arr2));

// 배열이 아니더라도 이터러블 객체이면 스프레드 문법을 사용할 수 있습니다.
let str1 = 'Hello';
console.log([...str1]);

// 스프레드 문법은 for..of 와 같은 방식으로 내부에서 이터레이터(iterator, 반복자)를 사용해 요소를 수집합니다.

// 메서드 Array.from 은 이터러블 객체인 문자열을 배열로 바꿔주기 때문에 Array.from 을 사용해도 동일한 작업을 할 수 있습니다.
let str2 = 'Hello';
console.log(Array.from(str2));

// 그런데 Array.from(obj) 와 [...obj] 는 다음과 같은 미묘한 차이가 있습니다.
// 1. Array.from 은 유사 배열 객체와 이터러블 객체 둘 다 사용할 수 있습니다.
// 2. 스프레드 문법은 이터러블 객체에만 사용할 수 있습니다.

// 이런 이유때문에 무언가를 배열로 바꿀 때는 스프레드 문법보다 Array.from 이 보편적으로 사용됩니다.













</script>