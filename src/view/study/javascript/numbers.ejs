<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title><%=pageName%></title>
    <link type="text/css" rel="stylesheet" href="/style/editor.css">
    <script type="text/javascript" src="/script/studyScript.js"></script>
</head>
<body>
    <div style="width: 100%; display: flex; justify-content: center;">
        <div style="padding: 10px 20px; border: 1px solid black; width: 1500PX;">
            <div class="button-area">
                <div style="display: flex; align-items: center;">
                    <h2 class="fileName" style="font-weight: 600;"><%=pageName%></h2>
                </div>
                <div>
                    <button id="pdfBtn" class="editor-button">pdf</button>
                    <button id="updateBtn" class="editor-button">수정</button>
                </div>
            </div>
            <div class="contents-section">
                <div>
                    <textarea id="editor" style="width:1455PX;height:700px;"></textarea>
                </div>
            </div>
        </div>
    </div>
    <input type="hidden" id="category" value="<%=category%>"/>
    <input type="hidden" id="page" value="<%=page%>"/>
</body>
</html>

<script>
    
// 숫자형

// 모던 자바스크립트는 숫자를 나타내는 두 가지 자료형을 지원합니다.

// 1. 일반적인 숫자는 '배정밀도 부동소수점 숫자' 로 알려진 64비트 형식의 IEEE-754 에 저장됩니다.
// 2. 임의의 길이를 가진 정수는 Bigint 숫자로 나타낼 수 있습니다.
// 일반적인 숫자는 2**56 이상이거나 -2**53 이하일수 없다는 제약 때문에 Bigint 라는 새로운 자료형이 만들어졌습니다.
// Bigint 는 아주 특별한 경우에만 사용되므로, 별도의 챕터 Bigint 에서 자세한 내용을 다루겠습니다.


// 숫자를 입력하는 다양한 방법

// 10억을 입력해야 한다고 상상해 봅시다.
// 가장 분명한 방법은 아래와 같이 직접 10억 을 써주는 것입니다.

let n1 = 1000000000;

// 그런데 이렇게 0을 많이 사용해 숫자를 표현하다 보면 잘못 입력하기 쉽기 때문에 실제로는 이런 방법을 잘 사용하지 않습니다.
// 0을 많이 입력하는 게 귀찮기도 하지요.
// 그래서 대개는 10억(billion)을 나타낼 땐 '1bn' 을 사용하고, 73억을 나타낼 땐 7.3bn 을 사용합니다.
// 큰 숫자를 나타낼 땐 이런 방법이 주로 사용되죠.

// 자바스크립트에서도 숫자 옆에 'e' 를 붙이고 0의 개수를 그 옆에 붙여주면 숫자를 줄일 수 있습니다.

let n2 = 1e9;
console.log(7.3e9);

// 즉 'e' 는 e 왼쪽의 수에 e 오른쪽에 있는 수만큼의 10의 거듭제곱을 곱하는 효과가 있습니다.

// 1e3 = 1 * 1000
// 1.23e6 = 1.23 = 1000000

// 이제 아주 작은 숫자인 1마이크로초(백만 분의 1초)를 표현해보겠습니다.

let n3 = 0.000001;

// 작은 숫자를 표현할 때도 큰 숫자를 표현할 때처럼 'e' 를 사용할 수 있습니다.
// 0을 명시적으로 쓰고 싶지 않다면 다음과 같이 숫자를 표현할 수 있죠.

let n4 = 1e-6;
console.log(n4);

// 1e-3 = 1 / 1000
// 1.23e-6 = 1.23 / 1000000


// 16진수, 2진수, 8진수

// 16진수는 색을 나타내거나 문자를 인코딩할 때 등 다양한 곳에서 두루 쓰입니다.
// 다양한 곳에서 쓰이는 만큼 당연히 16진수를 짧게 표현하는 방법도 존재하겠죠.
// 16진수는 0x 를 사용해 표현할 수 있습니다.

console.log(0xff);


// 2진수와 8진수는 아주 드물게 쓰이긴 하지만, 접두사 0b 와 0o 를 사용해 간단히 나타낼 수 있습니다.

let n5 = 0b11111111;
let n6 = 0o377;

console.log(n5);
console.log(n6);

// 자바스크립트에서 지원하는 진법은 3개입니다. 이 외에 진법을 사용하려면 함수 parseInt 를 사용해야 합니다.


// toString(base)

// num.toString(base) 메서드는 base 진법으로 num 을 표현한 후, 이를 문자형으로 변환해 반환합니다.

let n7 = 255;
console.log(n7.toString(16));
console.log(n7.toString(2));

// base 는 2 에서 36 까지 쓸 수 있는데, 기본값은 10 입니다.


// 어림수 구하기

// 어림수를 구하는 것은 숫자를 다룰 때 가장 많이 사용되는 연산 중 하나입니다.

// Math.floor
// 소수점 첫째 자리에서 내림

// Math.ceil
// 소수점 첫째 자리에서 올림

// Math.round
// 소수점 첫째 자리에서 반올림

// Math.trunc
// 소수부를 무시, IE 지원하지 않음

// 위에서 소개한 내장 함수들만으로도 소수부에 관련된 연산 대부분을 처리할 수 있습니다.
// 그런데 소수점 n-th 번째 수를 기준으로 어림수를 구해야 하는 상황이라면 어떻게 해야 할까요?

// 두 가지 방법이 있습니다.

// 1. 곱하기와 나누기
// 소수점 두 번째 자리 숫자까지만 남기고 싶은 경우, 숫자에 100 또는 100보다 큰 10의 거듭제곱 수를 곱한 후, 원하는 어림수 내장 함수를 호출하고 처음 곱한 수를 다시 나누면 됩니다.

let n8 = 1.23656;

console.log(Math.round(n8*100) / 100);


// 2. 소수점 n 번째 수까지 어림수를 구한 후 이를 문자형으로 반환해주는 메서드인 toFixed(n) 를 사용합니다.

console.log(n8.toFixed(2));


// 부정확한 계산

// 숫자는 내부적으로 64비트 형식 IEEE-754 으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요합니다.
// 64비트 중 52비트는 숫자를 저장하는 데 사용되고, 11비트는 소수점 위치를, 1비트는 부호를 저장하는데 사용됩니다.

// 그런데 숫자가 너무 커지면 64비트 공간이 넘쳐서 infinity 로 처리됩니다.

console.log(1e500);

// 원인을 이해하려면 집중이 필요하긴 하지만, 꽤 자주 발생하는 현상인 정밀도 손실(loss of precision)도 있습니다.

console.log(0.1+0.2 == 0.3);

// 0.1 과 0.2의 합이 0.3과 일치하는지 확인 했는데 false 가 출력되었습니다.

console.log(0.1+0.2); // 0.30000000000000004

// 숫자는 0과 1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장됩니다.
// 그런데 10진법을 사용하면 쉽게 표현할 수 있는 0.1, 0.2 같인 분수는 이진법으로 표현하면 무한 소수가 됩니다.

// 0.1 은 1을 10으로 나눈 수인 1/10 입니다.
// 10진법을 사용하면 이러한 숫자를 쉽게 표현할 수 있죠.
// 1/10 과 1/3을 비교해봅시다.
// 1/3은 무한 소수 0.33333(3) 이 됩니다.
console.log(1/3);

// 이렇게 10의 거듭제곱으로 나눈 값은 10진법에서 잘 작동하지만 3으로 나누게 되면 10진법에서 제대로 동작하지 않습니다.
// 같은 이유로 2진법 체계에서 2의 거듭제곱으로 나눈 값은 잘 동작하지만 1/10 같이 2의 거듭제곱이 아닌 값으로 나누게 되면 무한 소수가 되어버립니다.

// 10진법에서 1/3 을 정확히 나타낼 수 없듯이, 2진법을 사용해 0.1 또는 0.2를 정확하게 저장하는 방법은 없습니다.

// IEEE-754 에선 가장 가까운 숫자로 반올림하는 방법을 사용해 이런 문제를 해결합니다.
// 그런데 반올림 규칙을 적용하면 발생하는 작은 정밀도 손실을 우리가 볼 수는 없지만 실제로 손실은 발생합니다.

// 아래와 같이 코드를 작성하면 정밀도 손실을 눈으로 확인할 수 있죠.

console.log(0.1.toFixed(20));


// 자바스크립트 뿐만이 아닙니다.
// 다른 언어에서도 같은 이슈가 있습니다.
// 자바스크립트와 동일한 숫자 형식을 사용하기 때문에 PHP, Java, C, Perl, Ruby 에서도 똑같은 결과를 얻습니다.

// 문제를 해결하는 방법 중 가장 신뢰할만한 방법은 toFixed 메서드를 사용해 어림수를 만드는 것입니다.

let n9 = 0.1 + 0.2;
console.log(n9.toFixed(1));
console.log(typeof n9.toFixed(1));

// 이때 toFixed 는 항상 문자열을 반환한다는 점에 유의해야합니다.
// 다시 숫자형으로 강제 변환하려면 단항 덧셈 연산자를 사용하면 됩니다.

console.log(+n9.toFixed(1));
console.log(typeof +n9.toFixed(1));

// 무한 소수를 방지하는 완벽한 방법은 사실 없습니다.
// 필요할 때마다 꼬리를 잘라 어림수를 만드는 방법뿐이죠.


// 흥미로운 발견
console.log(9999999999999999); // 10000000000000000 출력

// 문제의 원인은 역시나 정밀도 손실 떄문입니다.
// 숫자를 저장할 땐 64비트가 사용되는데, 이 중 실제 숫자를 저장하는 데 사용되는 52비트에 위 숫자를 저장하기엔 공간이 모자랍니다.
// 따라서 최소 유효 숫자가 손실되어 버렸습니다.

// 자바스크립트는 숫자 손실이 일어나도 오류를 발생시키지 않습니다.
// 적절한 포맷으로 숫자를 맞추는 데 최선을 다하긴 하지만 유감스럽게도 위 예시의 숫자를 담기엔 포맷이 충분하지 않네요.


// 두 종류의 0

// 자바스크립트 내부에서 숫자를 표현하는 방식 때문에 발생하는 또 다른 흥미로운 현상은 0 과 -0 이라는 두 종류의 0이 존재한다는 사실입니다.
// 자바스크립트에선 숫자의 부호가 단일 비트에 저장되는데 0을 포함한 모든 숫자에 부호를 설정할 수도, 설정하지 않을 수도 있기 때문입니다.
// 대부분의 연산은 0과 -0 을 동일하게 취급하기 때문에 두 0의 차이는 두드러지지 않는 편입니다.


// isNaN 과 isFinite

// Infinity  와 -Infinity- 그 어떤 숫자보다 큰 혹은 작은 특수 숫자 값
// NaN - 에러를 나타내는 값

// 두 특수 숫자는 숫자형에 속하지만 정상적인 숫자는 아니기 때문에, 정상적인 숫자와 구분하기 위한 특별한 함수가 존재합니다.

// isNaN(value) - 인수를 숫자로 변환한 다음 NaN 인지 테스트함

console.log(`isNaN(NaN)`, isNaN(NaN));
console.log(`isNaN('123t')`, isNaN('123t'));

// 그런데 굳이 이 함수가 필요할까요? === NaN 비교를 하면 되지 않을까? 라는 생각이 들 수 있습니다.
// 안타깝게도 대답은 필요하다 입니다.
// NaN 은 NaN 자기 자신을 포함하여 그 어떤 값과도 같지 않다는 점에서 독특합니다.

console.log(`NaN === NaN`, NaN === NaN);

// isFinite(value) - 인수를 숫자로 반환하고 변환한 숫자가 NaN / Infinity / -Infinity 가 아닌 일반 숫자인 경우 true 를 반환함

console.log(`isFinite('15')`, isFinite('15'));
console.log(`isFinite('feaf')`, isFinite('feaf'));
console.log(`isFinite(Infinity)`, isFinite(Infinity));
console.log(`isFinite(NaN)`, isFinite(NaN));

// isFinite 는 문자열이 일반 숫자인지 검증하는 데 사용되곤 합니다.

// 빈 문자열이나 공백만 있는 문자열은 isFinite 를 포함한 모든 숫자 관련 내장 함수에서 0으로 취급된다는 점에 유의하시기 바랍니다.


// Object.is 와 비교하기

// Object.is 는 === 처럼 값을 비교할 때 사용되는 특별한 내장 메서드 인데, 아래와 같은 두 가지 케이스에선 === 보다 좀 더 신뢰할만한 결과를 보여줍니다.

// 1. NaN 을 대상으로 비교할 때: Object.is(NaN, NaN) === true 임

// 2. 0 과 -0 이 다르게 취급되어야 할 떄 : Object.is(0, -0) === false 임
// 숫자를 나타내는 비트가 모두 0이더라도 부호를 나타내는 비트는 다르므로 0과 -0 은 사실 다른 값이긴 합니다.

// 이 두 케이스를 제외하곤, Object.is(a,b) 와 a === b 의 결과는 같습니다.

// 이런 식의 비교는 자바스크립트 명세서에서 종종 찾아볼 수 있습니다.
// 내부 알고리즘에서 두 값을 비교해야 하는데, 비교 결과가 정확해야 하는 경우 Object.is 를 사용하죠.
// Object.is 에서 사 용되는 비교방식은 명세서에서 SameValue 라고 불립니다.


// parseInt 와 parseFloat

// 단항 덧셈 연산자 + 또는 Number() 를 사용하여 숫자형으로 변형할 때 적용되는 규칙은 꽤 엄격합니다.
// 피연산자가 숫자가 아니면 형 변환에 실패합니다.

console.log(`+'100px'`, +'100px');

// 엄격한 규칙이 적용되지 않는 유일한 예외는 문자열의 처음 또는 끝에 공백이 있어서 공백을 무시할 때 입니다.

// 그런데 실무에선 css 등에서 '100px', '12pt' 와 같이 숫자와 단위를 함께 쓰는 경우가 흔합니다.
// 대다수 국가에서 '19€' 처럼 금액 뒤에 통화 기호를 붙여 표시하기도 하죠.
// 숫자만 추출하는 방법이 필요해 보이네요.

// 내장 함수 parseInt 와 parseFloat 은 이런 경우를 위해 만들어졌습니다.

// 두 함수는 불가능할 때까지 문자열에서 숫자를 읽습니다.
// 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환하죠.
// parseInt 는 정수, parseFloat 은 부동 소수점 숫자를 반환합니다.

console.log(`parseInt('100px')`, parseInt('100px'));
console.log(`parseFloat('12.5em')`, parseFloat('12.5em'));

console.log(`parseInt('12.3')`, parseInt('12.3'));
console.log(`parseFloat('12.3.4')`, parseFloat('12.3.4'));

// parseInt 와 parseFloat 이 NaN 을 반환할 때도 있습니다.
// 읽을 수 있는 숫자가 없을 때 그렇죠.

console.log(`parseInt('a123')`, parseInt('a123'));


// parseInt(str, radix) 의 두 번째 인수

// parseInt() 의 두 번째 매개 변수는 선택적으로 사용할 수 있습니다.
// radix 는 원하는 진수를 지정해 줄 때 사용합니다.
// 따라서 parseInt 를 사용하면 16진수 문자열, 2진수 문자열 등을 파싱할 수 있습니다.

console.log(`parseInt('0xff', 16)`, parseInt('0xff', 16));
console.log(`parseInt('ff', 16)`, parseInt('ff', 16));
console.log(`parseInt('2n9c', 36)`, parseInt('2n9c', 36));


// 기타 수학 함수

// 자바스크립트에서 제공하는 내장 객체 Math 엔 다양한 수학 관련 함수와 상수들이 들어있습니다.

// Math.random()
// 0 과 1 사이의 난수를 반환합니다.
console.log('Math.random()', Math.random()) ;

// Math.max(a,b,c,...), Math.min(a,b,c,...)
// 인수 중 최대/최솟값을 반환합니다.

console.log('Math.max(3,2,-10,1,5,0)', Math.max(3,2,-10,1,5,0));
console.log('Math.min(3,2,-10,1,5,0)', Math.min(3,2,-10,1,5,0));

// Math.pow(n, power)
// n 을 power 번 거듭제곱한 값을 반환합니다.

console.log('Math.pow(2,10)', Math.pow(2,10));

// 이 외에도 삼각법을 포함한 다양한 함수와 상수가 Math 에 있습니다.


// 요약

// 0이 많이 붙은 큰 숫자는 다음과 같은 방법을 사용해 씁니다.
// 0의 개수를 'e' 뒤에 추가합니다. 123e6 은 0이 6개인 숫자, 123000000 을 나타냅니다.
// 'e' 다음에 음수가 나오면, 음수의 절댓값 만큼 10을 거듭제곱한 숫자로 주어진 숫자를 나눕니다
// 123e-6 은 0.000123 을 나타냅니다.

// 다양한 진법을 사용할 수도 있습니다.
// 자바스크립트는 특별한 변환 없이 16진수(0x), 8진수(0o), 2진수(0b) 를 바로 사용할 수 있게 지원합니다.
// parseInt(str, base) 를 사용하면 str 을 base 진수로 바꿔줍니다.
// num.toString(base) 는 숫자를 base 진수로 바꾸고, 이를 문자열 현태로 반환합니다.

// 12pt 나 100px와 같은 값을 숫자로 변환하는 것도 가능합니다.
// parseInt / parseFloat 를 사용하면 문자열에서 숫자만 읽고, 읽은 숫자를 에러가 발생하기 전에 반환해주는 '약한' 형 변환을 사용할 수 있습니다.

// 소수를 처리하는데 쓰이는 메서드는 다음과 같습니다.
// Math.floor, Math.ceil, Math.trunc, Math.round, num.toFixed(precision) 를 사용하면 어림수를 구할 수 있습니다.
// 소수를 다룰 땐 정밀도 손실에 주의해주세요.

// 이 외에도 다양한 수학 함수가 있습니다.
// 수학 연산이 필요할 떄 Math 객체를 찾아보세요. 작은 객체이지만 기본적인 연산은 대부분 다룰 수 있습니다.

</script>