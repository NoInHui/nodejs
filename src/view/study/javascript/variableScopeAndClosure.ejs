<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>변수의 유효범위와 클로저</title>
    <link type="text/css" rel="stylesheet" href="/style/editor.css">
    <script type="text/javascript" src="/script/studyScript.js"></script>
</head>
<body>
    <div style="width: 100%; display: flex; justify-content: center;">
        <div style="padding: 10px 20px; border: 1px solid black; width: 1500PX;">
            <div class="button-area">
                <div style="display: flex; align-items: center;">
                    <h2 class="fileName" style="font-weight: 600;">변수의 유효범위와 클로저</h2>
                </div>
                <div>
                    <button id="pdfBtn" class="editor-button">pdf</button>
                    <button id="updateBtn" class="editor-button">수정</button>
                </div>
            </div>
            <div class="contents-section">
                <div>
                    <textarea id="editor" style="width:1455PX;height:700px;"></textarea>
                </div>
            </div>
        </div>
    </div>
    <input type="hidden" id="category" value="<%=category%>"/>
    <input type="hidden" id="page" value="<%=page%>"/>
</body>
</html>

<script>
    // 변수의 유효범위와 클로저
    // 자바스크립트는 함수 지향 언어입니다.
    // 이런 특징은 개발자에게 많은 자유를 줍니다.
    // 함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에 인수로 넘길 수 있으며, 생성된 곳이 아닌 곳에서 함수를 호출할 수도 있기 때문입니다.
    
    // 여기선 let, const 로 선언한 변수만 다룸
    // 자바스크립트에서는 3개의 키워드를 사용해 변수를 선언할 수 있습니다. 모던한 방식의 let, const 가 있고 과거의 잔재인 var 도 있습니다.

    // 코드블록
    // 코드블록 {...} 안에서 서언한 변수는 블록 안에서만 사용할 수 있습니다.
    // 이미 선언된 변수와 동일한 이름을 가진 변수를 별도의 블록 없이 let 으로 선언하면 에러가 발생함
    // if, for, while 등에서도 마찬가지로 {...} 안에서 선언한 변수는 오직 블록 안에서만 접근 가능합니다.

    // 중첩함수 
    // 함수 내부에서 선언한 함수는 중첩함수라고 부릅니다.
    function say(fristName, lastName) {
        function getFullName() {
            return `${fristName} ${lastName}`;
        }

        console.log(`Hello, ${getFullName()}`);
        console.log(`Bye, ${getFullName()}`);
    }
    say('Noh','InHui');

    // 위 예시에서 외부 변수에 접근해 이름 전체를 반환해주는 중첩함수 getFullName() 은 편의상 만든 함수임, 이렇게 자바스크립트에선 중첩 함수가 흔히 사용됩니다.
    // 중첩함수는 새로운 객체의 프로퍼티 형태나 중첩함수 그 자체로 반환될 수 있다는 점에서 흥미롭습니다.
    // 이렇게 반환된 중첩 함수는 어디서든 호출해 사용할 수 있습니다. 물론 외부 변수에 접근할 수 있다는 사실은 변함 없습니다.

    function makeCounter() {
        let count = 0;

        return function() {
            return count++;
        }
    }

    let counter = makeCounter();
    console.log(counter());
    console.log(counter());
    console.log(counter());

    // console.log(makeCounter()());
    // console.log(makeCounter()());
    // console.log(makeCounter()());

    // 예시의 makeCounter 는 아주 단순하지만, 여기에 약간의 변형을 가하면 난수 생성기 같은 실용성 있는 함수를 만들 수 있습니다.
    // 그런데 makeCounter 를 살펴보다 보면 counter 를 여러 개 만들었을 때, 이 함수들은 서로 독립적일까? 함수와 중첩 함수 내 count 변수엔 어떤 값이 할당될까? 같은 의문이 들기 마련입니다.
    // 이런 의문을 해결할 수 있게 되면 자바스크립트 숙련도가 크게 올라갑니다. 좀 더 복잡한 시나리오도 다룰 수 있게되죠.
    

    // 렉시컬 환경
    // 렉시컬 환경의 명확한 이해를 돕기 위해 설명을 몆 개의 단계로 나눠서 진행하겠습니다.

    // 단계 1. 변수
    
    // 자바스크립트에선 실행 중인 함수, 코드 블록, 스크립트 전체는 렉시컬 환경이라 불리는 내부 숨김 연관 객체(internal hidden associated object)를 갖습니다.
    // 렉시컬 환경 객체는 두 부분으로 구성됩니다.
    // 1. 환경 레코드 - 모든 지역 변수를 프로퍼티로 저장하고 있는 객체입니다. this 값과 같은 기타 정보도 여기에 저장됩니다.
    // 2. 외부 렉시컬 환경에 대한 참조 - 외부 코드와 연관됨

    // 변수는 특수 내부 객체인 환경 레코드의 프로퍼티일 뿐입니다. 변수를 가져오거나 변경하는것은 환경 레코드의 프로퍼티를 가져오거나 변경함을 의미합니다 

    // 아래 두 줄짜리 코드엔 렉시컬 환경이 하나만 존재합니다.



    
</script>