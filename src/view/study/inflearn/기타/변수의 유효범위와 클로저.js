// Ctrl + Alt + N : 실행
const log = console.log;



// 렉시컬 환경

// 변수
// 자바스크립트에선 실행 중인 함수, 코드 블록 {...} 스크립트 전체는 렉시컬 환경이라 불리는 내부 숨김 연관 객체를 갖습니다.
// 렉시컬 환경 객체는 두 부분으로 구성됩니다.

// 1. 환경 레코드 : 모든 지역 변수를 프로퍼티로 저장하고 있는 객체입니다. this 값과 같은 기타 정보도 여기에 저장됩니다.
// 2. 외부 렉시컬 환경에 대한 참조 : 외부 코드와 연관됨

// 변수는 특수 내부 객체인 환경 레코드의 프로퍼티일 뿐입니다.
// 변수를 가져오거나 변경하는 것은 환경 레코드의 프로퍼티를 가져오거나 변경함을 의미합니다.

// 스크립트 전체와 관련된 렉시컬 환경은 전역 렉시컬 환경 이라고 부릅니다.
// 전역 렉시컬 환경은 외부 참조를 갖지 않기 때문에 화살표가 null 을 가리키는 걸 확인할 수 있습니다.


// 스크립트가 시작되면 스크립트 내에서 선언한 변수 전체가 렉시컬 환경에 올라갑니다.
// 이때 변수의 상태는 특수 내부 상태인 uninitialized 가 됩니다.
// 자바스크립트 엔진은 uninitialized 상태의 변수를 인지하긴 하지만, let 을 만나기 전까지 이 변수를 참조할 수 없습니다.

// let phrase 가 나타났네요ㅕ. 아직 값을 할당하기 전이기 때문에 프로퍼티 값은 undefined 입니다.


// 변수는 특수 내부 객체인 환경 레코드의 프로퍼티 입니다.
// 환경 레코드는 현재 실행 중인 함수와 코드 블록, 스크립트와 연관되어 있습니다.
// 변수를 변경하면 환경 레코드의 프로퍼티가 변경됩니다.

// 렉시컬 환경은 명세서에만 존재합니다.
// 렉시컬 환경은 명세서에서 자바스크립트가 어떻게 동작하는지 설명하는 데 쓰이는 이론상의 객체입니다.
// 따라서 코드를 사용해 직접 렉시컬 환경을 얻거나 조작하는 것은 불가능합니다.
// 자바스크립트 엔진들은 명세서에 언급된 사항을 준수하면서 엔진 고유의 방법을 사용해 렉시컬 환경을 최적화합니다.
// 사용하지 않는 변수를 버려 메모리를 절약하거나 다양한 내부 트릭을 써서 말이죠.


// 함수 선언문
// 함수는 변수와 마찬가지로 값입니다.
// 다만 함수 선언문으로 선언한 함수는 일반 변수와는 달리 바로 초기화된다는 점에서 차이가 있습니다.
// 함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용할 수 있습니다.
// 변수는 let 을 만나 선언이 될 때까지 사용할 수 없지만 말이죠.
// 선언되기 전에도 함수를 선언할 수 있는 것은 바로 이 때문입니다.
// 이런 동작 방식은 함수 선언문으로 정의한 함수에만 적용됩니다.
// let say = function() ... 같이 함수를 변수에 할당한 함수 표현식은 해당하지 않습니다.

// 내부와 외부 렉시컬 환경
// 함수를 호출해 실행하면 새로운 렉시컬 환경이 자동으로 만들어 집니다.
// 이 렉시컬 환경엔 함수 호출 시 넘겨받은 매개변수와 함수의 지역변수가 저장됩니다.
// 함수가 호출 중인 동안엔 호출 중인 함수를 위한 내부 렉시컬 환경과 내부 렉시컬 환경이 가리키는 외부 렉시컬 환경을 갖게 됩니다.
// 예시의 내부 렉시컬 환경은 현재 실행 중인 함수의 say 에 상응합니다.
// 내부 렉시컬 환경엔 함수의 인자인 name 프로퍼티 하나만 있습니다.
// 외부 렉시컬 환경은 전역 렉시컬 환경입니다. 전역 렉시컬 환경은 phrase 와 함수 say 를 프로퍼티로 갖습니다.

// 그리고 내부 렉시컬 환경은 외부 렉시컬 환경에 대한 참조를 갖습니다.

// 코드에서 변수에 접근할 때, 먼저 내부 렉시컬 환경을 검색범위로 잡습니다.
// 내부 렉시컬 환경에서 원하는 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장합니다.
// 이 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 떄까지 반복됩니다.

// 전역 렉시컬 환경에 도달할 때까지 변수를 찾지 못하면 엄격 모드에선 에러가 발생합니다.
// 참고로 비 엄격 모드에선 정의되지 않은 변수에 값을 할당하려고 하면 에러가 발생하는 대신 새로운 전역 변수가 만들어지는데, 이는 하위 호환성을 위해 남아있는 기능입니다.


// 함수를 반환하는 함수

// function makeCounter() {
//     let count = 0;
//     return () => {
//         return count++;
//     }
// }

// let counter1 = makeCounter;
// log(counter1()());
// log(counter1()());
// log(counter1()());

// let counter2 = makeCounter();
// log(counter2());
// log(counter2());
// log(counter2());

// let counter1 = makeCounter();
// let counter2 = makeCounter();

// log(counter1());
// log(counter1());
// log(counter1());
// log(counter2());
// log(counter2());


// makeCounter() 를 호출하면 호출할 때마다 새로운 렉시컬 환경 객체가 만들어지고 여기에 makeCounter 를 실행하는데 필요한 변수들이 저장됩니다.
// makeCounter() 가 실행되는 도중에 본문이 한줄 짜리인 중첩 함수가 만들어집니다.
// 여기서 중요한 사실이 하나 있습니다.
// 모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다는 점입니다.
// 함수는 [[Environment]] 라 불리는 숨김 프로퍼티를 갖는데, 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장됩니다.

// 따라서 couter.[[Environment]] 엔 {count: 0} 이 있는 렉시컬 환경에 대한 참조가 저장됩니다.

// 모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다는 점입니다.

// 호출 장소와 상관없이 함수가 자신이 태어난 곳을 기억할 수 있는 것은 바로 이 [[Environment]] 프로퍼티 덕분입니다.
// [[Environment]] 는 함수가 생성될 때 딱 한번 값이 세팅되고 영원히 변하지 않습니다.

// counter() 를 호출하면 각 호출마다 새로운 렉시컬 환경이 생성됩니다.
// 그리고 이 렉시컬 환경은 counter.[[Environment]] 에 저장된 렉시컬 환경을 외부 렉시컬 환경으로서 참조합니다.

// 실행 흐름이 함수의 본문으로 넘어오면 count 변수가 필요한데 먼저 자체 렉시컬 환경에서 변수를 찾습니다.
// 익명 중첩3 함수엔 지역변수가 없기 때문에 이 렉시컬 환경은 비어있는 상황입니다.
// 이제 counter() 의 렉시컬 환경이 참조하는 외부 렉시컬 환경에서 count 를 찾아봅시다.
// count 를 찾았습니다.

// 이제 count++ 가 실행되면서 cout 값이 1 증가해야하는데, 변숫값 갱신은 변수가 저장된 렉시컬 환경에서 이뤄집니다.


// 클로저
// 클로저는 개발자라면 알고 있어야 할 프로그래밍 용어입니다.
// 클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미합니다.
// 몆몆 언어에선 클로저를 구현하는게 불가능하거나 특수한 방식으로 함수를 작성해야 클로저를 만들 수 있습니다.
// 하지만 자바스크립트에선 모든 함수가 자연스럽게 클로저가 됩니다.
// 예외가 하나 있긴 한데 자세한 내용은 new Function 문법에서 다루도록 하겠습니다.

// 요점을 정리해 봅시다.
// 자바스크립트의 함수는 숨긴 프로퍼티인 [[Environment]] 를 이용해 자신이 어디서 만들어졌는지를 기억합니다.
// 함수 본문에선 [[Environment]] 를 사용해 외부변수에 접근합니다 


// 가비지 컬렉션
// 함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거됩니다.
// 함수와 관련된 변수들은 이때 모두 사라지죠.
// 함수 호출이 끝나면 관련 변수를 참조할 수 없는 이유가 바로 여기에 있습니다.
// 자바스크립트에서 모든 객체는 도달 가능한 상태일 때만 메모리에 유지됩니다.

// 그런데 호출이 끝난 후에도 여전히 도달 가능한 중첩함수가 있을 수 있습니다.
// 이때는 이 중첩함수의 [[Environment]] 프로퍼티에 외부 함수 렉시컬 환경에 대한 정보가 저장됩니다.
// 도달 가능한 상태가 되는 것이죠.

function f() {
    let value = 123;
    return () => {
        log(value);
    }
}

let g = f(); // g.[[Environment]] 에 f() 호출 시 만들어지는 렉시컬 환경 정보가 저장됩니다.
g();

// 그런데 이렇게 중첩함수를 사용할 때는 주의할 점이 있습니다.
// f() 를 여러번 호출하고 그 결과를 어딘가에 저장하는 경우, 호출 시 만들어지는 각 렉시컬 환경 모두가 메모리에 유지된다는 점입니다.

// function f() {
//     let value = Math.random();
//     // return () => console.log(value);
//     return function() {
//         console.log(value);
//     }
// }

// let arr = [f(),f(),f()];

// console.log(arr[0]());
// console.log(arr[1]());
// console.log(arr[2]());

function Counter() {
    let count = 0;

    this.up = () => ++count;
    this.down = () => --count;
}

let counter = new Counter();

console.log(counter.up());
console.log(counter.up());
console.log(counter.down());

// 생성자 함수의 두 중첩 함수는 동일한 외부 렉시컬 환경이 만들어졌기 때문에 같은 count 변수를 공유합니다.


function sum(a) {
    return (b) => a+b;
}

console.log(sum(1)(2));
console.log(sum(5)(-1));



let x = 1;
function func() {
    console.log(x); -> // function 이 실행되면서 x 가 밑에 있지만 이미 초기화되어있는 상태겠구나..
    let x = 2;
}

func();


let arr = [1, 2, 3, 4, 5, 6, 7];

function inBetween(a,b) {
    return x => x >=a && x <= b;
}

console.log(arr.filter(inBetween(3,6)));

function inArray([...args]) {
    // return x => args.indexOf(x) > -1 ? true : false
    return x => args.includes(x);
}

console.log(arr.filter(inArray([1,2,10])));


let users = [
    { name: "John", age: 20, surname: "Johnson" },
    { name: "Pete", age: 18, surname: "Peterson" },
    { name: "Ann", age: 19, surname: "Hathaway" }
];

function byField(key) {
    return (a,b) => a[key] > b[key] ? -1 : 1;
}

console.log(users.sort(byField('name')));
console.log(users.sort(byField('age')));


function makeArmy() {
    let shooters = [];
    
    let i = 0;
    while(i<10) {
        let shooter = function() {
            console.log(i);
        }

        shooters.push(shooter);
        i++;
    }
    return shooters;
}

let army = makeArmy();

army[0]();
army[5]();