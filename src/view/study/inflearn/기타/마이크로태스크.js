// Ctrl + Alt + N : 실행
const log = console.log;

// 마이크로태스크

// 프라미스 핸들러 .then / catch / finally 는 항상 비동기적으로 실행됩니다.

let promise = Promise.resolve();
promise.then(() => console.log('promise'));
console.log('not promise');

// 마이크로태스크 큐
// 비동기 작업을 처리하려면 적절한 관리가 필요합니다.
// 이를 위해 ECMA 에선 PromiseJobs 라는 내부 큐를 명시합니다.
// V8엔진에선 이를 마이크로태스크 큐 라고 부르기 때문에 이 용어가 좀 더 선호됩니다.

// 마이크로태스크 큐는 먼저 들어온 작업을 먼저 실행합니다.
// 실행할 것이 아무것도 남아있지 않을 때만 마이크로태스크 큐에 있는 작업이 실행되기 시작합니다.

// 요약하자면, 어떤 프라미스가 준비되었을 때 이 프라미스의 then  catch finally 핸들러가 큐에 들어간다고 생각하시면 됩니다.
// 이때 핸들러들은 여전히 실행되지 않습니다.
// 현재 코드에서 자유로운 상태가 되었을때에서야 자바스크립트 엔진은 큐에서 작업을 꺼내 실행합니다.


// 이벤트 루프와 매크로태스크, 마이크로태스크

// 브라우저 측 자바스크립트 실행 흐름은 Node.js 와 마찬가지로 이벤트 루프에 기반합니다.
// 따라서 이벤트 루프가 어떻게 동작하는지 잘 이해하고 있어야 최적화나 올바른 아키텍처 설계가 가능해집니다.

// 이벤트 루프
// 이벤트 루프 정의는 아주 간단합니다.
// 이벤트 루프는 태스크가 들어오길 기다렸다가 태스크가 들어오면 이를 처리하고, 처리할 태스크가 없는 경우엔 잠드는, 끊임없이 돌아가는 자바스크립트 내 루프입니다.
// 자바스크립트 엔진이 돌아가는 알고리즘을 일반화하면 다음과 같습니다.

// 1. 처리해야 할 태스크가 있는 경우
// 먼저 들어온 태스크부터 순차적으로 처리함

// 2. 처리해야 할 태스크가 없는 경우
// 잠들어 있다가 새로운 태스크가 추가되면 다시 1로 돌아감

// 바로 이 알고리즘이 우리가 브라우저를 사용해 인터넷 서핑할 때 돌아가는 알고리즘 입니다.
// 이렇게 자바스크립트 엔진은 대부분의 시간 동안 아무런 일도 하지 않고 쉬고 있따가 스크립트나 핸들러, 이벤트가 활성화될 때만 돌아갑니다.
// 그렇다면 자바스크립트 엔진을 활성화하는 태스크엔 과연 어떤것들이 있을까요?

// 외부 스크립트 <script src=""> 가 로드될 때, 이 스크립트를 실행하는 것
// 사용자가 마우스를 움직일 때 mousemove 이벤트와 이벤트 핸들러를 실행하는 것
// setTimeout 에서 설정한 시간이 다 된 경우 콜백 함수를 실행하는 것
// 기타 등등

// 태스크는 하나의 집합을 이룹니다.
// 자바스크립트 엔진은 집합을 이루고 있는 태스크들을 차례대로 처리하고 새로운 태스크가 추가될 때까지 기다립니다.
// 태스크를 기다리는 동안엔 CPU 자원 소비는 0에 가까워지고 엔진은 잠들게 됩니다.
// 새로운 태스크는 엔진이 바쁠 때 추가될 수도 있습니다.
// 이때 이 태스크는 큐에 추가됩니 다.
// 이렇게 태스크가 추가되는 큐는 V8 용어로 매크로태스크 큐 라고 부릅니다.

// 좀 더 구체적인 사례를 가지고 매크로태스크 큐에 대해 알아봅시다.
// 엔진이 script 를 처리하느라 바쁜데 사용자가 마우스를 움직여 mousemove 이벤트를 활성화하고, 바로 이어서 setTImeout 에서 설정한 시간이 지났다고 가정해봅시다.

// 큐에 있는 태스크들은 들어간 순서대로 처리됩니다.
// 엔진은 script 를 먼저 처리하고 mousemove 이벤트와 핸들러, setTimeout 핸들러를 순차적으로 처리합니다.

// 1. 엔진이 특정 태스크를 처리하는 동안엔 렌더링이 절대 일어나지 않습니다.
// 태스크를 처리하는 데 걸리는 시간이 길지 않으면 이는 전혀 문제가 되지 않습니다.
// 처리가 끝나는 대로 DOM 변경을 화면에 반영하면 되기 때문입니다.

// 2. 태스크 처리에 긴 시간이 걸리면, 브라우저는 태스크를 처리하는 동안에 발생한 사용자 이벤트 등의 새로운 태스크들을 처리하지 못합니다.
// 인터넷 서핑을 하다 보면 응답 ㄷ없는 페이지 라는 얼럿 창을 만나게 되는 경우가 종종 있습니다.
// 이 얼럿 창은 아주 복잡한 계산이 필요하거나 프로그래밍 에러 때문에 무한루프에 빠지게 될 때 나타나는데,
// 브라우저는 얼럿 창을 통해 사용자에게 페이지 전체와 함께 해당 태스크를 취소시킬지 말지를 선택하도록 유도합니다.


// 자바스크립트 엔진은 매크로태스크 하나를 처리할 때마다 또 다른 매크로태스크나 렌더링 작업을 하기 전에 마이크로태스크 큐에 쌓인 마이크로태스크 전부를 처리합니다.


setTimeout(() => console.log('setTimeout'));
Promise.resolve().then(() => console.log('Promise'));
console.log('code1');
console.log('code2');
console.log('code3');
console.log('code4');
console.log('code5');
console.log('code6');
for(let i=0; i<1e9;i++) {
    if(i==1e9-1) console.log(i);
}

// 1. 일반적인 동기 호출이 가장 먼저 매크로태스크 큐에 들어간 후 실행됩니다.
// 2. promise .then 은 마이크로태스크 큐에 들어가 처리되기 때문에 

// 