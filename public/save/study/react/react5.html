<div style="color: rgb(212, 212, 212); background-color: rgb(30, 30, 30); font-family: Consolas, &quot;Courier New&quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;"><div><span style="color: #c586c0;">import</span> <span style="color: #9cdcfe;">React</span>, { <span style="color: #9cdcfe;">Component</span> } <span style="color: #c586c0;">from</span> <span style="color: #ce9178;">'react'</span>;</div><br><div><span style="color: #6a9955;">// State and Lifecycle</span></div><br><div><span style="color: #569cd6;">class</span> <span style="color: #4ec9b0;">ReactOfficial4</span> <span style="color: #569cd6;">extends</span> <span style="color: #4ec9b0;">Component</span> {</div><div>&nbsp; &nbsp; <span style="color: #dcdcaa;">render</span>() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #c586c0;">return</span> (</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080;">&lt;</span><span style="color: #4ec9b0;">Clock</span><span style="color: #808080;">&gt;&lt;/</span><span style="color: #4ec9b0;">Clock</span><span style="color: #808080;">&gt;</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; );</div><div>&nbsp; &nbsp; }</div><div>}</div><br><div><span style="color: #569cd6;">class</span> <span style="color: #4ec9b0;">Clock</span> <span style="color: #569cd6;">extends</span> <span style="color: #4ec9b0;">Component</span> {</div><div>&nbsp; &nbsp; <span style="color: #569cd6;">constructor</span>(<span style="color: #9cdcfe;">props</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #6a9955;">// 클래스 컴포넌트는 항상 props 로 기본 constructor 를 호출해야합니다.</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #569cd6;">super</span>(<span style="color: #9cdcfe;">props</span>);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #569cd6;">this</span>.<span style="color: #9cdcfe;">state</span> = {<span style="color: #9cdcfe;">date</span><span style="color: #9cdcfe;">:</span> <span style="color: #569cd6;">new</span> <span style="color: #4ec9b0;">Date</span>()};</div><div>&nbsp; &nbsp; }</div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 생명주기 메서드를 클래스에 추가하기</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 많은 컴포넌트가 있는 애플리케이션에서 컴포넌트가 삭제될 때 해당 컴포넌트가 사용 중이던 리소스를 확보하는 것이 중요합니다.</span></div><div>&nbsp; &nbsp; </div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// Click 이 처음 DOM 에 렌더링 될 때마다 타이머를 설정하려고 합니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 이것을 React 에서 '마운팅' 이라고 합니다.</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 또한 Clock 에 의해 생성된 DOM 이 삭제될 때마다 타이머를 해제하려고 합니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 이것을 React 에서 '언마운팅' 이라고 합니다.</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 컴포넌트 클래스에서 특별한 메서드를 선언하면 컴포넌트가 마운트 되거나 언마운트 될 때 일부 코드를 작동할 수 있습니다.</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 이런 메서드들은 '생명주기 메서드' 라고 불립니다.</span></div><br><div>&nbsp; &nbsp; </div><div>&nbsp; &nbsp; <span style="color: #dcdcaa;">componentDidMount</span>() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #6a9955;">// componentDidMount() 메서드는 컴포넌트 출력물이 DOM 에 랜더링 된 후에 실행됩니다.</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #6a9955;">// 이 장소가 타이머를 설정하기에 좋은 장소입니다.</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #569cd6;">this</span>.<span style="color: #9cdcfe;">timerID</span> = <span style="color: #dcdcaa;">setInterval</span>(() <span style="color: #569cd6;">=&gt;</span> <span style="color: #569cd6;">this</span>.<span style="color: #dcdcaa;">tick</span>(), <span style="color: #b5cea8;">1000</span>);</div><div>&nbsp; &nbsp; }</div><br><div>&nbsp; &nbsp; <span style="color: #dcdcaa;">componentWillUnmount</span>() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #dcdcaa;">clearInterval</span>(<span style="color: #569cd6;">this</span>.<span style="color: #9cdcfe;">timerID</span>);</div><div>&nbsp; &nbsp; }</div><br><div>&nbsp; &nbsp; <span style="color: #dcdcaa;">tick</span>() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #569cd6;">this</span>.<span style="color: #dcdcaa;">setState</span>(<span style="color: #9cdcfe;">prevState</span> <span style="color: #569cd6;">=&gt;</span> ({</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #9cdcfe;">date</span><span style="color: #9cdcfe;">:</span> <span style="color: #569cd6;">new</span> <span style="color: #4ec9b0;">Date</span>()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }));</div><div>&nbsp; &nbsp; }</div><br><br><div>&nbsp; &nbsp; <span style="color: #dcdcaa;">render</span>() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #c586c0;">return</span> (</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">h1</span><span style="color: #808080;">&gt;</span>Hello, world!<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">h1</span><span style="color: #808080;">&gt;</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080;">&lt;</span><span style="color: #569cd6;">h2</span><span style="color: #808080;">&gt;</span>It is <span style="color: #569cd6;">{</span><span style="color: #569cd6;">this</span>.<span style="color: #9cdcfe;">state</span>.<span style="color: #9cdcfe;">date</span>.<span style="color: #dcdcaa;">toLocaleTimeString</span>()<span style="color: #569cd6;">}</span>.<span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">h2</span><span style="color: #808080;">&gt;</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080;">&lt;/</span><span style="color: #569cd6;">div</span><span style="color: #808080;">&gt;</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; )</div><div>&nbsp; &nbsp; }</div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 메서드가 어떻게 호출되는지 순서대로 빠르게 요약해 보겠습니다.</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 1. &lt;Clock/&gt; 가 render 로 전달되었을 때 React 는 Clock 컴포넌트의 constructor 를 호출합니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// Clock 이 현재 시각을 표시해야 하기 때문에 현재 시각이 포함된 객체로 this.state 를 초기화합니다.</span></div><div>&nbsp; &nbsp; </div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 2. React 는 Clock 컴포넌트의 render() 메서드를 호출합니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 이를 통해 React 는 화면에 표시되어야 할 내용을 알게 됩니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 그 다음 React 는 Clock 의 렌더링 출력값을 일치시키기 위해 DOM 을 업데이트 합니다.</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 3. Clock 출력값이 DOM 에 삽입되면, React 는 componentDidMount() 생명주기 메서드를 호출합니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 그 안에서 Clock 컴포넌트는 매초 컴포넌트의 tick() 메서드를 호출하기 위한 타이머 설정하도록 브라우저에 요청합니다.</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 4. 매초 브라우저가 tick() 메서드를 호출합니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 그 안에서 Clock 컴포넌트는 setState() 에 현재 시각을 포함하는 객체를 호출하면서 UI 업데이트를 진행합니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// setState() 호출 덕분에 React 는 state 가 변경된 것을 인지하고 화면에 표시될 내용을 알아내기 위해 render() 메서드를 다시 호출합니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 이 때 render() 메서드 안의 this.state.date 가 달리지고 렌더링 출력값은 업데이트된 시각을 포함합니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// React 는 이에 따라 DOM 을 업데이트 합니다.</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 5. Clock 컴포넌트가 DOM 으로부터 한 번이라도 삭제된 적이 있다면 React 는 타이머를 멈추기 위해 componentWillUnmount() 생명주기 메서드를 호출합니다.</span></div><br><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// State 를 올바르게 사용하기</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// setState() 에 대해서 알아야 할 세 가지가 있습니다.</span></div><div>&nbsp; &nbsp; </div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 1. 직접 State 를 수정하지 마세요.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 예를 들어, 이 코드는 컴포넌트를 다시 렌더링 하지 않습니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// this.state.comment = 'Hello';</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 대신에 setState() 를 사용합니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// this.setState({comment: 'Hello'});</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// this.state 를 지정할 수 있는 유일한 공간은 constructor 입니다.</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 2. State 업데이트는 비동기적일 수도 있습니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// React 는 성능을 위해 여러 setState() 호출을 단일 업데이트로 한꺼번에 처리할 수 있습니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// this.props 와 this.state 가 비동기적으로 업데이트될 수 있기 때문에 다음 state 를 계산할 때 해당 값에 의존해서는 안 됩니다.</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 예를 들어, 다음 코드는 카운터 업데이트에 실패할 수 있습니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// this.setState({</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; counter: this.state.counter + this.props.increment</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// });</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 이를 수정하기 위해 객체보다는 함수를 인자로 사용하는 다른 형태의 setState() 를 사용합니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 그 함수는 이전 state 를 첫번째 인자로 받아들일 것이고, 업데이트가 적용된 시점의 props 를 두 번째 인자로 받아들일 것입니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// this.setState((state, props) =&gt; ({</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; counter: state.counter + props.increment</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// }));</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 위에서는 화살표 함수를 사용했지만, 일반적인 함수에서도 정상적으로 작동합니다.</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// this.setState(function(state, props) {</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; return {</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; &nbsp; &nbsp; counter: state.counter + props.increment</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; };</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// });</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 3. State 업데이트는 병합됩니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// setState() 를 호출할 때 React 는 제공한 객체를 현재 state 로 병합합니다.</span></div><div>&nbsp; &nbsp; </div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// constructor(props) {</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; super(props);</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; this.state = {</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; &nbsp; &nbsp; posts: [],</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; &nbsp; &nbsp; comments: [],</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; }</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// }</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// componentDidMount() {</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; fetchPosts().then(response =&gt; {</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; &nbsp; &nbsp; this.setState({</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; posts: response.posts</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; &nbsp; &nbsp; });</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; });</span></div><div>&nbsp; &nbsp; &nbsp; </div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; fetchComments().then(response =&gt; {</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; this.setState({</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; &nbsp; &nbsp; comments: response.comments</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; });</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// &nbsp; &nbsp; }); &nbsp; &nbsp; &nbsp;</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// }</span></div><br><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 별도의 setState() 호출로 변수를 독립적으로 업데이트할 수 있습니다.</span></div><div>&nbsp; &nbsp; <span style="color: #6a9955;">// 병합은 얕게 이루어지기 때문에 this.setState({comment}) 는 this.state.posts 에 영향을 주진 않지만 this.state.comments 는 완전히 대체됩니다.</span></div><br><div>}</div><br><div><span style="color: #c586c0;">export</span> <span style="color: #c586c0;">default</span> <span style="color: #4ec9b0;">ReactOfficial4</span>;</div></div>